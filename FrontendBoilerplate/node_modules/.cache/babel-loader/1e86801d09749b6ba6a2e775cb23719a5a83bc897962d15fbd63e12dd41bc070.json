{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar React = _interopRequireWildcard(require(\"react\"));\nvar _fastEquals = require(\"fast-equals\");\nvar _clsx = _interopRequireDefault(require(\"clsx\"));\nvar _utils = require(\"./utils\");\nvar _calculateUtils = require(\"./calculateUtils\");\nvar _GridItem = _interopRequireDefault(require(\"./GridItem\"));\nvar _ReactGridLayoutPropTypes = _interopRequireDefault(require(\"./ReactGridLayoutPropTypes\"));\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return typeof key === \"symbol\" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\n/*:: import type {\n  ChildrenArray as ReactChildrenArray,\n  Element as ReactElement\n} from \"react\";*/\n/*:: import type {\n  CompactType,\n  GridResizeEvent,\n  GridDragEvent,\n  DragOverEvent,\n  Layout,\n  DroppingPosition,\n  LayoutItem\n} from \"./utils\";*/\n// Types\n/*:: import type { PositionParams } from \"./calculateUtils\";*/\n/*:: type State = {\n  activeDrag: ?LayoutItem,\n  layout: Layout,\n  mounted: boolean,\n  oldDragItem: ?LayoutItem,\n  oldLayout: ?Layout,\n  oldResizeItem: ?LayoutItem,\n  resizing: boolean,\n  droppingDOMNode: ?ReactElement<any>,\n  droppingPosition?: DroppingPosition,\n  // Mirrored props\n  children: ReactChildrenArray<ReactElement<any>>,\n  compactType?: CompactType,\n  propsLayout?: Layout\n};*/\n/*:: import type { Props, DefaultProps } from \"./ReactGridLayoutPropTypes\";*/\n// End Types\nconst layoutClassName = \"react-grid-layout\";\nlet isFirefox = false;\n// Try...catch will protect from navigator not existing (e.g. node) or a bad implementation of navigator\ntry {\n  isFirefox = /firefox/i.test(navigator.userAgent);\n} catch (e) {\n  /* Ignore */\n}\n\n/**\n * A reactive, fluid grid layout with draggable, resizable components.\n */\n\nclass ReactGridLayout extends React.Component /*:: <Props, State>*/ {\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"state\", {\n      activeDrag: null,\n      layout: (0, _utils.synchronizeLayoutWithChildren)(this.props.layout, this.props.children, this.props.cols,\n      // Legacy support for verticalCompact: false\n      (0, _utils.compactType)(this.props), this.props.allowOverlap),\n      mounted: false,\n      oldDragItem: null,\n      oldLayout: null,\n      oldResizeItem: null,\n      resizing: false,\n      droppingDOMNode: null,\n      children: []\n    });\n    _defineProperty(this, \"dragEnterCounter\", 0);\n    /**\n     * When dragging starts\n     * @param {String} i Id of the child\n     * @param {Number} x X position of the move\n     * @param {Number} y Y position of the move\n     * @param {Event} e The mousedown event\n     * @param {Element} node The current dragging DOM element\n     */\n    _defineProperty(this, \"onDragStart\", (i /*: string*/, x /*: number*/, y /*: number*/, _ref /*:: */) => {\n      let {\n        e,\n        node\n      } /*: GridDragEvent*/ = _ref /*: GridDragEvent*/;\n      const {\n        layout\n      } = this.state;\n      const l = (0, _utils.getLayoutItem)(layout, i);\n      if (!l) return;\n      this.setState({\n        oldDragItem: (0, _utils.cloneLayoutItem)(l),\n        oldLayout: layout\n      });\n      return this.props.onDragStart(layout, l, l, null, e, node);\n    });\n    /**\n     * Each drag movement create a new dragelement and move the element to the dragged location\n     * @param {String} i Id of the child\n     * @param {Number} x X position of the move\n     * @param {Number} y Y position of the move\n     * @param {Event} e The mousedown event\n     * @param {Element} node The current dragging DOM element\n     */\n    _defineProperty(this, \"onDrag\", (i, x, y, _ref2) => {\n      let {\n        e,\n        node\n      } = _ref2;\n      const {\n        oldDragItem\n      } = this.state;\n      let {\n        layout\n      } = this.state;\n      const {\n        cols,\n        allowOverlap,\n        preventCollision\n      } = this.props;\n      const l = (0, _utils.getLayoutItem)(layout, i);\n      if (!l) return;\n\n      // Create placeholder (display only)\n      const placeholder = {\n        w: l.w,\n        h: l.h,\n        x: l.x,\n        y: l.y,\n        placeholder: true,\n        i: i\n      };\n\n      // Move the element to the dragged location.\n      const isUserAction = true;\n      layout = (0, _utils.moveElement)(layout, l, x, y, isUserAction, preventCollision, (0, _utils.compactType)(this.props), cols, allowOverlap);\n      this.props.onDrag(layout, oldDragItem, l, placeholder, e, node);\n      this.setState({\n        layout: allowOverlap ? layout : (0, _utils.compact)(layout, (0, _utils.compactType)(this.props), cols),\n        activeDrag: placeholder\n      });\n    });\n    /**\n     * When dragging stops, figure out which position the element is closest to and update its x and y.\n     * @param  {String} i Index of the child.\n     * @param {Number} x X position of the move\n     * @param {Number} y Y position of the move\n     * @param {Event} e The mousedown event\n     * @param {Element} node The current dragging DOM element\n     */\n    _defineProperty(this, \"onDragStop\", (i, x, y, _ref3) => {\n      let {\n        e,\n        node\n      } = _ref3;\n      if (!this.state.activeDrag) return;\n      const {\n        oldDragItem\n      } = this.state;\n      let {\n        layout\n      } = this.state;\n      const {\n        cols,\n        preventCollision,\n        allowOverlap\n      } = this.props;\n      const l = (0, _utils.getLayoutItem)(layout, i);\n      if (!l) return;\n\n      // Move the element here\n      const isUserAction = true;\n      layout = (0, _utils.moveElement)(layout, l, x, y, isUserAction, preventCollision, (0, _utils.compactType)(this.props), cols, allowOverlap);\n\n      // Set state\n      const newLayout = allowOverlap ? layout : (0, _utils.compact)(layout, (0, _utils.compactType)(this.props), cols);\n      this.props.onDragStop(newLayout, oldDragItem, l, null, e, node);\n      const {\n        oldLayout\n      } = this.state;\n      this.setState({\n        activeDrag: null,\n        layout: newLayout,\n        oldDragItem: null,\n        oldLayout: null\n      });\n      this.onLayoutMaybeChanged(newLayout, oldLayout);\n    });\n    _defineProperty(this, \"onResizeStart\", (i, w, h, _ref4) => {\n      let {\n        e,\n        node\n      } = _ref4;\n      const {\n        layout\n      } = this.state;\n      const l = (0, _utils.getLayoutItem)(layout, i);\n      if (!l) return;\n      this.setState({\n        oldResizeItem: (0, _utils.cloneLayoutItem)(l),\n        oldLayout: this.state.layout,\n        resizing: true\n      });\n      this.props.onResizeStart(layout, l, l, null, e, node);\n    });\n    _defineProperty(this, \"onResize\", (i, w, h, _ref5) => {\n      let {\n        e,\n        node,\n        size,\n        handle\n      } = _ref5;\n      const {\n        oldResizeItem\n      } = this.state;\n      let {\n        layout\n      } = this.state;\n      const {\n        cols,\n        preventCollision,\n        allowOverlap\n      } = this.props;\n      let shouldMoveItem = false;\n      let finalLayout;\n      let x;\n      let y;\n      const [newLayout, l] = (0, _utils.withLayoutItem)(layout, i, l => {\n        let hasCollisions;\n        x = l.x;\n        y = l.y;\n        if ([\"sw\", \"w\", \"nw\", \"n\", \"ne\"].indexOf(handle) !== -1) {\n          if ([\"sw\", \"nw\", \"w\"].indexOf(handle) !== -1) {\n            x = l.x + (l.w - w);\n            w = l.x !== x && x < 0 ? l.w : w;\n            x = x < 0 ? 0 : x;\n          }\n          if ([\"ne\", \"n\", \"nw\"].indexOf(handle) !== -1) {\n            y = l.y + (l.h - h);\n            h = l.y !== y && y < 0 ? l.h : h;\n            y = y < 0 ? 0 : y;\n          }\n          shouldMoveItem = true;\n        }\n\n        // Something like quad tree should be used\n        // to find collisions faster\n        if (preventCollision && !allowOverlap) {\n          const collisions = (0, _utils.getAllCollisions)(layout, {\n            ...l,\n            w,\n            h,\n            x,\n            y\n          }).filter(layoutItem => layoutItem.i !== l.i);\n          hasCollisions = collisions.length > 0;\n\n          // If we're colliding, we need adjust the placeholder.\n          if (hasCollisions) {\n            // Reset layoutItem dimensions if there were collisions\n            y = l.y;\n            h = l.h;\n            x = l.x;\n            w = l.w;\n            shouldMoveItem = false;\n          }\n        }\n        l.w = w;\n        l.h = h;\n        return l;\n      });\n\n      // Shouldn't ever happen, but typechecking makes it necessary\n      if (!l) return;\n      finalLayout = newLayout;\n      if (shouldMoveItem) {\n        // Move the element to the new position.\n        const isUserAction = true;\n        finalLayout = (0, _utils.moveElement)(newLayout, l, x, y, isUserAction, this.props.preventCollision, (0, _utils.compactType)(this.props), cols, allowOverlap);\n      }\n\n      // Create placeholder element (display only)\n      const placeholder = {\n        w: l.w,\n        h: l.h,\n        x: l.x,\n        y: l.y,\n        static: true,\n        i: i\n      };\n      this.props.onResize(finalLayout, oldResizeItem, l, placeholder, e, node);\n\n      // Re-compact the newLayout and set the drag placeholder.\n      this.setState({\n        layout: allowOverlap ? finalLayout : (0, _utils.compact)(finalLayout, (0, _utils.compactType)(this.props), cols),\n        activeDrag: placeholder\n      });\n    });\n    _defineProperty(this, \"onResizeStop\", (i, w, h, _ref6) => {\n      let {\n        e,\n        node\n      } = _ref6;\n      const {\n        layout,\n        oldResizeItem\n      } = this.state;\n      const {\n        cols,\n        allowOverlap\n      } = this.props;\n      const l = (0, _utils.getLayoutItem)(layout, i);\n\n      // Set state\n      const newLayout = allowOverlap ? layout : (0, _utils.compact)(layout, (0, _utils.compactType)(this.props), cols);\n      this.props.onResizeStop(newLayout, oldResizeItem, l, null, e, node);\n      const {\n        oldLayout\n      } = this.state;\n      this.setState({\n        activeDrag: null,\n        layout: newLayout,\n        oldResizeItem: null,\n        oldLayout: null,\n        resizing: false\n      });\n      this.onLayoutMaybeChanged(newLayout, oldLayout);\n    });\n    // Called while dragging an element. Part of browser native drag/drop API.\n    // Native event target might be the layout itself, or an element within the layout.\n    _defineProperty(this, \"onDragOver\", e => {\n      var _e$nativeEvent$target;\n      e.preventDefault(); // Prevent any browser native action\n      e.stopPropagation();\n\n      // we should ignore events from layout's children in Firefox\n      // to avoid unpredictable jumping of a dropping placeholder\n      // FIXME remove this hack\n      if (isFirefox &&\n      // $FlowIgnore can't figure this out\n      !((_e$nativeEvent$target = e.nativeEvent.target) !== null && _e$nativeEvent$target !== void 0 && _e$nativeEvent$target.classList.contains(layoutClassName))) {\n        return false;\n      }\n      const {\n        droppingItem,\n        onDropDragOver,\n        margin,\n        cols,\n        rowHeight,\n        maxRows,\n        width,\n        containerPadding,\n        transformScale\n      } = this.props;\n      // Allow user to customize the dropping item or short-circuit the drop based on the results\n      // of the `onDragOver(e: Event)` callback.\n      const onDragOverResult = onDropDragOver === null || onDropDragOver === void 0 ? void 0 : onDropDragOver(e);\n      if (onDragOverResult === false) {\n        if (this.state.droppingDOMNode) {\n          this.removeDroppingPlaceholder();\n        }\n        return false;\n      }\n      const finalDroppingItem = {\n        ...droppingItem,\n        ...onDragOverResult\n      };\n      const {\n        layout\n      } = this.state;\n      // This is relative to the DOM element that this event fired for.\n      const {\n        layerX,\n        layerY\n      } = e.nativeEvent;\n      const droppingPosition = {\n        left: layerX / transformScale,\n        top: layerY / transformScale,\n        e\n      };\n      if (!this.state.droppingDOMNode) {\n        const positionParams /*: PositionParams*/ = {\n          cols,\n          margin,\n          maxRows,\n          rowHeight,\n          containerWidth: width,\n          containerPadding: containerPadding || margin\n        };\n        const calculatedPosition = (0, _calculateUtils.calcXY)(positionParams, layerY, layerX, finalDroppingItem.w, finalDroppingItem.h);\n        this.setState({\n          droppingDOMNode: /*#__PURE__*/React.createElement(\"div\", {\n            key: finalDroppingItem.i\n          }),\n          droppingPosition,\n          layout: [...layout, {\n            ...finalDroppingItem,\n            x: calculatedPosition.x,\n            y: calculatedPosition.y,\n            static: false,\n            isDraggable: true\n          }]\n        });\n      } else if (this.state.droppingPosition) {\n        const {\n          left,\n          top\n        } = this.state.droppingPosition;\n        const shouldUpdatePosition = left != layerX || top != layerY;\n        if (shouldUpdatePosition) {\n          this.setState({\n            droppingPosition\n          });\n        }\n      }\n    });\n    _defineProperty(this, \"removeDroppingPlaceholder\", () => {\n      const {\n        droppingItem,\n        cols\n      } = this.props;\n      const {\n        layout\n      } = this.state;\n      const newLayout = (0, _utils.compact)(layout.filter(l => l.i !== droppingItem.i), (0, _utils.compactType)(this.props), cols, this.props.allowOverlap);\n      this.setState({\n        layout: newLayout,\n        droppingDOMNode: null,\n        activeDrag: null,\n        droppingPosition: undefined\n      });\n    });\n    _defineProperty(this, \"onDragLeave\", e => {\n      e.preventDefault(); // Prevent any browser native action\n      e.stopPropagation();\n      this.dragEnterCounter--;\n\n      // onDragLeave can be triggered on each layout's child.\n      // But we know that count of dragEnter and dragLeave events\n      // will be balanced after leaving the layout's container\n      // so we can increase and decrease count of dragEnter and\n      // when it'll be equal to 0 we'll remove the placeholder\n      if (this.dragEnterCounter === 0) {\n        this.removeDroppingPlaceholder();\n      }\n    });\n    _defineProperty(this, \"onDragEnter\", e => {\n      e.preventDefault(); // Prevent any browser native action\n      e.stopPropagation();\n      this.dragEnterCounter++;\n    });\n    _defineProperty(this, \"onDrop\", (e /*: Event*/) => {\n      e.preventDefault(); // Prevent any browser native action\n      e.stopPropagation();\n      const {\n        droppingItem\n      } = this.props;\n      const {\n        layout\n      } = this.state;\n      const item = layout.find(l => l.i === droppingItem.i);\n\n      // reset dragEnter counter on drop\n      this.dragEnterCounter = 0;\n      this.removeDroppingPlaceholder();\n      this.props.onDrop(layout, item, e);\n    });\n  }\n  componentDidMount() {\n    this.setState({\n      mounted: true\n    });\n    // Possibly call back with layout on mount. This should be done after correcting the layout width\n    // to ensure we don't rerender with the wrong width.\n    this.onLayoutMaybeChanged(this.state.layout, this.props.layout);\n  }\n  static getDerivedStateFromProps(nextProps /*: Props*/, prevState /*: State*/) /*: $Shape<State> | null*/{\n    let newLayoutBase;\n    if (prevState.activeDrag) {\n      return null;\n    }\n\n    // Legacy support for compactType\n    // Allow parent to set layout directly.\n    if (!(0, _fastEquals.deepEqual)(nextProps.layout, prevState.propsLayout) || nextProps.compactType !== prevState.compactType) {\n      newLayoutBase = nextProps.layout;\n    } else if (!(0, _utils.childrenEqual)(nextProps.children, prevState.children)) {\n      // If children change, also regenerate the layout. Use our state\n      // as the base in case because it may be more up to date than\n      // what is in props.\n      newLayoutBase = prevState.layout;\n    }\n\n    // We need to regenerate the layout.\n    if (newLayoutBase) {\n      const newLayout = (0, _utils.synchronizeLayoutWithChildren)(newLayoutBase, nextProps.children, nextProps.cols, (0, _utils.compactType)(nextProps), nextProps.allowOverlap);\n      return {\n        layout: newLayout,\n        // We need to save these props to state for using\n        // getDerivedStateFromProps instead of componentDidMount (in which we would get extra rerender)\n        compactType: nextProps.compactType,\n        children: nextProps.children,\n        propsLayout: nextProps.layout\n      };\n    }\n    return null;\n  }\n  shouldComponentUpdate(nextProps /*: Props*/, nextState /*: State*/) /*: boolean*/{\n    return (\n      // NOTE: this is almost always unequal. Therefore the only way to get better performance\n      // from SCU is if the user intentionally memoizes children. If they do, and they can\n      // handle changes properly, performance will increase.\n      this.props.children !== nextProps.children || !(0, _utils.fastRGLPropsEqual)(this.props, nextProps, _fastEquals.deepEqual) || this.state.activeDrag !== nextState.activeDrag || this.state.mounted !== nextState.mounted || this.state.droppingPosition !== nextState.droppingPosition\n    );\n  }\n  componentDidUpdate(prevProps /*: Props*/, prevState /*: State*/) {\n    if (!this.state.activeDrag) {\n      const newLayout = this.state.layout;\n      const oldLayout = prevState.layout;\n      this.onLayoutMaybeChanged(newLayout, oldLayout);\n    }\n  }\n\n  /**\n   * Calculates a pixel value for the container.\n   * @return {String} Container height in pixels.\n   */\n  containerHeight() /*: ?string*/{\n    if (!this.props.autoSize) return;\n    const nbRow = (0, _utils.bottom)(this.state.layout);\n    const containerPaddingY = this.props.containerPadding ? this.props.containerPadding[1] : this.props.margin[1];\n    return nbRow * this.props.rowHeight + (nbRow - 1) * this.props.margin[1] + containerPaddingY * 2 + \"px\";\n  }\n  onLayoutMaybeChanged(newLayout /*: Layout*/, oldLayout /*: ?Layout*/) {\n    if (!oldLayout) oldLayout = this.state.layout;\n    if (!(0, _fastEquals.deepEqual)(oldLayout, newLayout)) {\n      this.props.onLayoutChange(newLayout);\n    }\n  }\n  /**\n   * Create a placeholder object.\n   * @return {Element} Placeholder div.\n   */\n  placeholder() /*: ?ReactElement<any>*/{\n    const {\n      activeDrag\n    } = this.state;\n    if (!activeDrag) return null;\n    const {\n      width,\n      cols,\n      margin,\n      containerPadding,\n      rowHeight,\n      maxRows,\n      useCSSTransforms,\n      transformScale\n    } = this.props;\n\n    // {...this.state.activeDrag} is pretty slow, actually\n    return /*#__PURE__*/React.createElement(_GridItem.default, {\n      w: activeDrag.w,\n      h: activeDrag.h,\n      x: activeDrag.x,\n      y: activeDrag.y,\n      i: activeDrag.i,\n      className: \"react-grid-placeholder \".concat(this.state.resizing ? \"placeholder-resizing\" : \"\"),\n      containerWidth: width,\n      cols: cols,\n      margin: margin,\n      containerPadding: containerPadding || margin,\n      maxRows: maxRows,\n      rowHeight: rowHeight,\n      isDraggable: false,\n      isResizable: false,\n      isBounded: false,\n      useCSSTransforms: useCSSTransforms,\n      transformScale: transformScale\n    }, /*#__PURE__*/React.createElement(\"div\", null));\n  }\n\n  /**\n   * Given a grid item, set its style attributes & surround in a <Draggable>.\n   * @param  {Element} child React element.\n   * @return {Element}       Element wrapped in draggable and properly placed.\n   */\n  processGridItem(child /*: ReactElement<any>*/, isDroppingItem /*: boolean*/) /*: ?ReactElement<any>*/{\n    if (!child || !child.key) return;\n    const l = (0, _utils.getLayoutItem)(this.state.layout, String(child.key));\n    if (!l) return null;\n    const {\n      width,\n      cols,\n      margin,\n      containerPadding,\n      rowHeight,\n      maxRows,\n      isDraggable,\n      isResizable,\n      isBounded,\n      useCSSTransforms,\n      transformScale,\n      draggableCancel,\n      draggableHandle,\n      resizeHandles,\n      resizeHandle\n    } = this.props;\n    const {\n      mounted,\n      droppingPosition\n    } = this.state;\n\n    // Determine user manipulations possible.\n    // If an item is static, it can't be manipulated by default.\n    // Any properties defined directly on the grid item will take precedence.\n    const draggable = typeof l.isDraggable === \"boolean\" ? l.isDraggable : !l.static && isDraggable;\n    const resizable = typeof l.isResizable === \"boolean\" ? l.isResizable : !l.static && isResizable;\n    const resizeHandlesOptions = l.resizeHandles || resizeHandles;\n\n    // isBounded set on child if set on parent, and child is not explicitly false\n    const bounded = draggable && isBounded && l.isBounded !== false;\n    return /*#__PURE__*/React.createElement(_GridItem.default, {\n      containerWidth: width,\n      cols: cols,\n      margin: margin,\n      containerPadding: containerPadding || margin,\n      maxRows: maxRows,\n      rowHeight: rowHeight,\n      cancel: draggableCancel,\n      handle: draggableHandle,\n      onDragStop: this.onDragStop,\n      onDragStart: this.onDragStart,\n      onDrag: this.onDrag,\n      onResizeStart: this.onResizeStart,\n      onResize: this.onResize,\n      onResizeStop: this.onResizeStop,\n      isDraggable: draggable,\n      isResizable: resizable,\n      isBounded: bounded,\n      useCSSTransforms: useCSSTransforms && mounted,\n      usePercentages: !mounted,\n      transformScale: transformScale,\n      w: l.w,\n      h: l.h,\n      x: l.x,\n      y: l.y,\n      i: l.i,\n      minH: l.minH,\n      minW: l.minW,\n      maxH: l.maxH,\n      maxW: l.maxW,\n      static: l.static,\n      droppingPosition: isDroppingItem ? droppingPosition : undefined,\n      resizeHandles: resizeHandlesOptions,\n      resizeHandle: resizeHandle\n    }, child);\n  }\n  render() /*: React.Element<\"div\">*/{\n    const {\n      className,\n      style,\n      isDroppable,\n      innerRef\n    } = this.props;\n    const mergedClassName = (0, _clsx.default)(layoutClassName, className);\n    const mergedStyle = {\n      height: this.containerHeight(),\n      ...style\n    };\n    return /*#__PURE__*/React.createElement(\"div\", {\n      ref: innerRef,\n      className: mergedClassName,\n      style: mergedStyle,\n      onDrop: isDroppable ? this.onDrop : _utils.noop,\n      onDragLeave: isDroppable ? this.onDragLeave : _utils.noop,\n      onDragEnter: isDroppable ? this.onDragEnter : _utils.noop,\n      onDragOver: isDroppable ? this.onDragOver : _utils.noop\n    }, React.Children.map(this.props.children, child => this.processGridItem(child)), isDroppable && this.state.droppingDOMNode && this.processGridItem(this.state.droppingDOMNode, true), this.placeholder());\n  }\n}\nexports.default = ReactGridLayout;\n// TODO publish internal ReactClass displayName transform\n_defineProperty(ReactGridLayout, \"displayName\", \"ReactGridLayout\");\n// Refactored to another module to make way for preval\n_defineProperty(ReactGridLayout, \"propTypes\", _ReactGridLayoutPropTypes.default);\n_defineProperty(ReactGridLayout, \"defaultProps\", {\n  autoSize: true,\n  cols: 12,\n  className: \"\",\n  style: {},\n  draggableHandle: \"\",\n  draggableCancel: \"\",\n  containerPadding: null,\n  rowHeight: 150,\n  maxRows: Infinity,\n  // infinite vertical growth\n  layout: [],\n  margin: [10, 10],\n  isBounded: false,\n  isDraggable: true,\n  isResizable: true,\n  allowOverlap: false,\n  isDroppable: false,\n  useCSSTransforms: true,\n  transformScale: 1,\n  verticalCompact: true,\n  compactType: \"vertical\",\n  preventCollision: false,\n  droppingItem: {\n    i: \"__dropping-elem__\",\n    h: 1,\n    w: 1\n  },\n  resizeHandles: [\"se\"],\n  onLayoutChange: _utils.noop,\n  onDragStart: _utils.noop,\n  onDrag: _utils.noop,\n  onDragStop: _utils.noop,\n  onResizeStart: _utils.noop,\n  onResize: _utils.noop,\n  onResizeStop: _utils.noop,\n  onDrop: _utils.noop,\n  onDropDragOver: _utils.noop\n});","map":{"version":3,"names":["Object","defineProperty","exports","value","default","React","_interopRequireWildcard","require","_fastEquals","_clsx","_interopRequireDefault","_utils","_calculateUtils","_GridItem","_ReactGridLayoutPropTypes","obj","__esModule","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","cache","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","_defineProperty","_toPropertyKey","enumerable","configurable","writable","arg","_toPrimitive","String","input","hint","prim","Symbol","toPrimitive","undefined","res","TypeError","Number","layoutClassName","isFirefox","test","navigator","userAgent","e","ReactGridLayout","Component","constructor","arguments","activeDrag","layout","synchronizeLayoutWithChildren","props","children","cols","compactType","allowOverlap","mounted","oldDragItem","oldLayout","oldResizeItem","resizing","droppingDOMNode","i","x","y","_ref","node","state","l","getLayoutItem","setState","cloneLayoutItem","onDragStart","_ref2","preventCollision","placeholder","w","h","isUserAction","moveElement","onDrag","compact","_ref3","newLayout","onDragStop","onLayoutMaybeChanged","_ref4","onResizeStart","_ref5","size","handle","shouldMoveItem","finalLayout","withLayoutItem","hasCollisions","indexOf","collisions","getAllCollisions","filter","layoutItem","length","static","onResize","_ref6","onResizeStop","_e$nativeEvent$target","preventDefault","stopPropagation","nativeEvent","target","classList","contains","droppingItem","onDropDragOver","margin","rowHeight","maxRows","width","containerPadding","transformScale","onDragOverResult","removeDroppingPlaceholder","finalDroppingItem","layerX","layerY","droppingPosition","left","top","positionParams","containerWidth","calculatedPosition","calcXY","createElement","isDraggable","shouldUpdatePosition","dragEnterCounter","item","find","onDrop","componentDidMount","getDerivedStateFromProps","nextProps","prevState","newLayoutBase","deepEqual","propsLayout","childrenEqual","shouldComponentUpdate","nextState","fastRGLPropsEqual","componentDidUpdate","prevProps","containerHeight","autoSize","nbRow","bottom","containerPaddingY","onLayoutChange","useCSSTransforms","className","concat","isResizable","isBounded","processGridItem","child","isDroppingItem","draggableCancel","draggableHandle","resizeHandles","resizeHandle","draggable","resizable","resizeHandlesOptions","bounded","cancel","usePercentages","minH","minW","maxH","maxW","render","style","isDroppable","innerRef","mergedClassName","mergedStyle","height","ref","noop","onDragLeave","onDragEnter","onDragOver","Children","map","Infinity","verticalCompact"],"sources":["/Users/kenzman/Desktop/ethglobal/MEDISYNC/Frontend Boilerplate/node_modules/react-grid-layout/build/ReactGridLayout.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar React = _interopRequireWildcard(require(\"react\"));\nvar _fastEquals = require(\"fast-equals\");\nvar _clsx = _interopRequireDefault(require(\"clsx\"));\nvar _utils = require(\"./utils\");\nvar _calculateUtils = require(\"./calculateUtils\");\nvar _GridItem = _interopRequireDefault(require(\"./GridItem\"));\nvar _ReactGridLayoutPropTypes = _interopRequireDefault(require(\"./ReactGridLayoutPropTypes\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n/*:: import type {\n  ChildrenArray as ReactChildrenArray,\n  Element as ReactElement\n} from \"react\";*/\n/*:: import type {\n  CompactType,\n  GridResizeEvent,\n  GridDragEvent,\n  DragOverEvent,\n  Layout,\n  DroppingPosition,\n  LayoutItem\n} from \"./utils\";*/\n// Types\n/*:: import type { PositionParams } from \"./calculateUtils\";*/\n/*:: type State = {\n  activeDrag: ?LayoutItem,\n  layout: Layout,\n  mounted: boolean,\n  oldDragItem: ?LayoutItem,\n  oldLayout: ?Layout,\n  oldResizeItem: ?LayoutItem,\n  resizing: boolean,\n  droppingDOMNode: ?ReactElement<any>,\n  droppingPosition?: DroppingPosition,\n  // Mirrored props\n  children: ReactChildrenArray<ReactElement<any>>,\n  compactType?: CompactType,\n  propsLayout?: Layout\n};*/\n/*:: import type { Props, DefaultProps } from \"./ReactGridLayoutPropTypes\";*/\n// End Types\nconst layoutClassName = \"react-grid-layout\";\nlet isFirefox = false;\n// Try...catch will protect from navigator not existing (e.g. node) or a bad implementation of navigator\ntry {\n  isFirefox = /firefox/i.test(navigator.userAgent);\n} catch (e) {\n  /* Ignore */\n}\n\n/**\n * A reactive, fluid grid layout with draggable, resizable components.\n */\n\nclass ReactGridLayout extends React.Component /*:: <Props, State>*/{\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"state\", {\n      activeDrag: null,\n      layout: (0, _utils.synchronizeLayoutWithChildren)(this.props.layout, this.props.children, this.props.cols,\n      // Legacy support for verticalCompact: false\n      (0, _utils.compactType)(this.props), this.props.allowOverlap),\n      mounted: false,\n      oldDragItem: null,\n      oldLayout: null,\n      oldResizeItem: null,\n      resizing: false,\n      droppingDOMNode: null,\n      children: []\n    });\n    _defineProperty(this, \"dragEnterCounter\", 0);\n    /**\n     * When dragging starts\n     * @param {String} i Id of the child\n     * @param {Number} x X position of the move\n     * @param {Number} y Y position of the move\n     * @param {Event} e The mousedown event\n     * @param {Element} node The current dragging DOM element\n     */\n    _defineProperty(this, \"onDragStart\", (i /*: string*/, x /*: number*/, y /*: number*/, _ref /*:: */) => {\n      let {\n        e,\n        node\n      } /*: GridDragEvent*/ = _ref /*: GridDragEvent*/;\n      const {\n        layout\n      } = this.state;\n      const l = (0, _utils.getLayoutItem)(layout, i);\n      if (!l) return;\n      this.setState({\n        oldDragItem: (0, _utils.cloneLayoutItem)(l),\n        oldLayout: layout\n      });\n      return this.props.onDragStart(layout, l, l, null, e, node);\n    });\n    /**\n     * Each drag movement create a new dragelement and move the element to the dragged location\n     * @param {String} i Id of the child\n     * @param {Number} x X position of the move\n     * @param {Number} y Y position of the move\n     * @param {Event} e The mousedown event\n     * @param {Element} node The current dragging DOM element\n     */\n    _defineProperty(this, \"onDrag\", (i, x, y, _ref2) => {\n      let {\n        e,\n        node\n      } = _ref2;\n      const {\n        oldDragItem\n      } = this.state;\n      let {\n        layout\n      } = this.state;\n      const {\n        cols,\n        allowOverlap,\n        preventCollision\n      } = this.props;\n      const l = (0, _utils.getLayoutItem)(layout, i);\n      if (!l) return;\n\n      // Create placeholder (display only)\n      const placeholder = {\n        w: l.w,\n        h: l.h,\n        x: l.x,\n        y: l.y,\n        placeholder: true,\n        i: i\n      };\n\n      // Move the element to the dragged location.\n      const isUserAction = true;\n      layout = (0, _utils.moveElement)(layout, l, x, y, isUserAction, preventCollision, (0, _utils.compactType)(this.props), cols, allowOverlap);\n      this.props.onDrag(layout, oldDragItem, l, placeholder, e, node);\n      this.setState({\n        layout: allowOverlap ? layout : (0, _utils.compact)(layout, (0, _utils.compactType)(this.props), cols),\n        activeDrag: placeholder\n      });\n    });\n    /**\n     * When dragging stops, figure out which position the element is closest to and update its x and y.\n     * @param  {String} i Index of the child.\n     * @param {Number} x X position of the move\n     * @param {Number} y Y position of the move\n     * @param {Event} e The mousedown event\n     * @param {Element} node The current dragging DOM element\n     */\n    _defineProperty(this, \"onDragStop\", (i, x, y, _ref3) => {\n      let {\n        e,\n        node\n      } = _ref3;\n      if (!this.state.activeDrag) return;\n      const {\n        oldDragItem\n      } = this.state;\n      let {\n        layout\n      } = this.state;\n      const {\n        cols,\n        preventCollision,\n        allowOverlap\n      } = this.props;\n      const l = (0, _utils.getLayoutItem)(layout, i);\n      if (!l) return;\n\n      // Move the element here\n      const isUserAction = true;\n      layout = (0, _utils.moveElement)(layout, l, x, y, isUserAction, preventCollision, (0, _utils.compactType)(this.props), cols, allowOverlap);\n\n      // Set state\n      const newLayout = allowOverlap ? layout : (0, _utils.compact)(layout, (0, _utils.compactType)(this.props), cols);\n      this.props.onDragStop(newLayout, oldDragItem, l, null, e, node);\n      const {\n        oldLayout\n      } = this.state;\n      this.setState({\n        activeDrag: null,\n        layout: newLayout,\n        oldDragItem: null,\n        oldLayout: null\n      });\n      this.onLayoutMaybeChanged(newLayout, oldLayout);\n    });\n    _defineProperty(this, \"onResizeStart\", (i, w, h, _ref4) => {\n      let {\n        e,\n        node\n      } = _ref4;\n      const {\n        layout\n      } = this.state;\n      const l = (0, _utils.getLayoutItem)(layout, i);\n      if (!l) return;\n      this.setState({\n        oldResizeItem: (0, _utils.cloneLayoutItem)(l),\n        oldLayout: this.state.layout,\n        resizing: true\n      });\n      this.props.onResizeStart(layout, l, l, null, e, node);\n    });\n    _defineProperty(this, \"onResize\", (i, w, h, _ref5) => {\n      let {\n        e,\n        node,\n        size,\n        handle\n      } = _ref5;\n      const {\n        oldResizeItem\n      } = this.state;\n      let {\n        layout\n      } = this.state;\n      const {\n        cols,\n        preventCollision,\n        allowOverlap\n      } = this.props;\n      let shouldMoveItem = false;\n      let finalLayout;\n      let x;\n      let y;\n      const [newLayout, l] = (0, _utils.withLayoutItem)(layout, i, l => {\n        let hasCollisions;\n        x = l.x;\n        y = l.y;\n        if ([\"sw\", \"w\", \"nw\", \"n\", \"ne\"].indexOf(handle) !== -1) {\n          if ([\"sw\", \"nw\", \"w\"].indexOf(handle) !== -1) {\n            x = l.x + (l.w - w);\n            w = l.x !== x && x < 0 ? l.w : w;\n            x = x < 0 ? 0 : x;\n          }\n          if ([\"ne\", \"n\", \"nw\"].indexOf(handle) !== -1) {\n            y = l.y + (l.h - h);\n            h = l.y !== y && y < 0 ? l.h : h;\n            y = y < 0 ? 0 : y;\n          }\n          shouldMoveItem = true;\n        }\n\n        // Something like quad tree should be used\n        // to find collisions faster\n        if (preventCollision && !allowOverlap) {\n          const collisions = (0, _utils.getAllCollisions)(layout, {\n            ...l,\n            w,\n            h,\n            x,\n            y\n          }).filter(layoutItem => layoutItem.i !== l.i);\n          hasCollisions = collisions.length > 0;\n\n          // If we're colliding, we need adjust the placeholder.\n          if (hasCollisions) {\n            // Reset layoutItem dimensions if there were collisions\n            y = l.y;\n            h = l.h;\n            x = l.x;\n            w = l.w;\n            shouldMoveItem = false;\n          }\n        }\n        l.w = w;\n        l.h = h;\n        return l;\n      });\n\n      // Shouldn't ever happen, but typechecking makes it necessary\n      if (!l) return;\n      finalLayout = newLayout;\n      if (shouldMoveItem) {\n        // Move the element to the new position.\n        const isUserAction = true;\n        finalLayout = (0, _utils.moveElement)(newLayout, l, x, y, isUserAction, this.props.preventCollision, (0, _utils.compactType)(this.props), cols, allowOverlap);\n      }\n\n      // Create placeholder element (display only)\n      const placeholder = {\n        w: l.w,\n        h: l.h,\n        x: l.x,\n        y: l.y,\n        static: true,\n        i: i\n      };\n      this.props.onResize(finalLayout, oldResizeItem, l, placeholder, e, node);\n\n      // Re-compact the newLayout and set the drag placeholder.\n      this.setState({\n        layout: allowOverlap ? finalLayout : (0, _utils.compact)(finalLayout, (0, _utils.compactType)(this.props), cols),\n        activeDrag: placeholder\n      });\n    });\n    _defineProperty(this, \"onResizeStop\", (i, w, h, _ref6) => {\n      let {\n        e,\n        node\n      } = _ref6;\n      const {\n        layout,\n        oldResizeItem\n      } = this.state;\n      const {\n        cols,\n        allowOverlap\n      } = this.props;\n      const l = (0, _utils.getLayoutItem)(layout, i);\n\n      // Set state\n      const newLayout = allowOverlap ? layout : (0, _utils.compact)(layout, (0, _utils.compactType)(this.props), cols);\n      this.props.onResizeStop(newLayout, oldResizeItem, l, null, e, node);\n      const {\n        oldLayout\n      } = this.state;\n      this.setState({\n        activeDrag: null,\n        layout: newLayout,\n        oldResizeItem: null,\n        oldLayout: null,\n        resizing: false\n      });\n      this.onLayoutMaybeChanged(newLayout, oldLayout);\n    });\n    // Called while dragging an element. Part of browser native drag/drop API.\n    // Native event target might be the layout itself, or an element within the layout.\n    _defineProperty(this, \"onDragOver\", e => {\n      var _e$nativeEvent$target;\n      e.preventDefault(); // Prevent any browser native action\n      e.stopPropagation();\n\n      // we should ignore events from layout's children in Firefox\n      // to avoid unpredictable jumping of a dropping placeholder\n      // FIXME remove this hack\n      if (isFirefox &&\n      // $FlowIgnore can't figure this out\n      !((_e$nativeEvent$target = e.nativeEvent.target) !== null && _e$nativeEvent$target !== void 0 && _e$nativeEvent$target.classList.contains(layoutClassName))) {\n        return false;\n      }\n      const {\n        droppingItem,\n        onDropDragOver,\n        margin,\n        cols,\n        rowHeight,\n        maxRows,\n        width,\n        containerPadding,\n        transformScale\n      } = this.props;\n      // Allow user to customize the dropping item or short-circuit the drop based on the results\n      // of the `onDragOver(e: Event)` callback.\n      const onDragOverResult = onDropDragOver === null || onDropDragOver === void 0 ? void 0 : onDropDragOver(e);\n      if (onDragOverResult === false) {\n        if (this.state.droppingDOMNode) {\n          this.removeDroppingPlaceholder();\n        }\n        return false;\n      }\n      const finalDroppingItem = {\n        ...droppingItem,\n        ...onDragOverResult\n      };\n      const {\n        layout\n      } = this.state;\n      // This is relative to the DOM element that this event fired for.\n      const {\n        layerX,\n        layerY\n      } = e.nativeEvent;\n      const droppingPosition = {\n        left: layerX / transformScale,\n        top: layerY / transformScale,\n        e\n      };\n      if (!this.state.droppingDOMNode) {\n        const positionParams /*: PositionParams*/ = {\n          cols,\n          margin,\n          maxRows,\n          rowHeight,\n          containerWidth: width,\n          containerPadding: containerPadding || margin\n        };\n        const calculatedPosition = (0, _calculateUtils.calcXY)(positionParams, layerY, layerX, finalDroppingItem.w, finalDroppingItem.h);\n        this.setState({\n          droppingDOMNode: /*#__PURE__*/React.createElement(\"div\", {\n            key: finalDroppingItem.i\n          }),\n          droppingPosition,\n          layout: [...layout, {\n            ...finalDroppingItem,\n            x: calculatedPosition.x,\n            y: calculatedPosition.y,\n            static: false,\n            isDraggable: true\n          }]\n        });\n      } else if (this.state.droppingPosition) {\n        const {\n          left,\n          top\n        } = this.state.droppingPosition;\n        const shouldUpdatePosition = left != layerX || top != layerY;\n        if (shouldUpdatePosition) {\n          this.setState({\n            droppingPosition\n          });\n        }\n      }\n    });\n    _defineProperty(this, \"removeDroppingPlaceholder\", () => {\n      const {\n        droppingItem,\n        cols\n      } = this.props;\n      const {\n        layout\n      } = this.state;\n      const newLayout = (0, _utils.compact)(layout.filter(l => l.i !== droppingItem.i), (0, _utils.compactType)(this.props), cols, this.props.allowOverlap);\n      this.setState({\n        layout: newLayout,\n        droppingDOMNode: null,\n        activeDrag: null,\n        droppingPosition: undefined\n      });\n    });\n    _defineProperty(this, \"onDragLeave\", e => {\n      e.preventDefault(); // Prevent any browser native action\n      e.stopPropagation();\n      this.dragEnterCounter--;\n\n      // onDragLeave can be triggered on each layout's child.\n      // But we know that count of dragEnter and dragLeave events\n      // will be balanced after leaving the layout's container\n      // so we can increase and decrease count of dragEnter and\n      // when it'll be equal to 0 we'll remove the placeholder\n      if (this.dragEnterCounter === 0) {\n        this.removeDroppingPlaceholder();\n      }\n    });\n    _defineProperty(this, \"onDragEnter\", e => {\n      e.preventDefault(); // Prevent any browser native action\n      e.stopPropagation();\n      this.dragEnterCounter++;\n    });\n    _defineProperty(this, \"onDrop\", (e /*: Event*/) => {\n      e.preventDefault(); // Prevent any browser native action\n      e.stopPropagation();\n      const {\n        droppingItem\n      } = this.props;\n      const {\n        layout\n      } = this.state;\n      const item = layout.find(l => l.i === droppingItem.i);\n\n      // reset dragEnter counter on drop\n      this.dragEnterCounter = 0;\n      this.removeDroppingPlaceholder();\n      this.props.onDrop(layout, item, e);\n    });\n  }\n  componentDidMount() {\n    this.setState({\n      mounted: true\n    });\n    // Possibly call back with layout on mount. This should be done after correcting the layout width\n    // to ensure we don't rerender with the wrong width.\n    this.onLayoutMaybeChanged(this.state.layout, this.props.layout);\n  }\n  static getDerivedStateFromProps(nextProps /*: Props*/, prevState /*: State*/) /*: $Shape<State> | null*/{\n    let newLayoutBase;\n    if (prevState.activeDrag) {\n      return null;\n    }\n\n    // Legacy support for compactType\n    // Allow parent to set layout directly.\n    if (!(0, _fastEquals.deepEqual)(nextProps.layout, prevState.propsLayout) || nextProps.compactType !== prevState.compactType) {\n      newLayoutBase = nextProps.layout;\n    } else if (!(0, _utils.childrenEqual)(nextProps.children, prevState.children)) {\n      // If children change, also regenerate the layout. Use our state\n      // as the base in case because it may be more up to date than\n      // what is in props.\n      newLayoutBase = prevState.layout;\n    }\n\n    // We need to regenerate the layout.\n    if (newLayoutBase) {\n      const newLayout = (0, _utils.synchronizeLayoutWithChildren)(newLayoutBase, nextProps.children, nextProps.cols, (0, _utils.compactType)(nextProps), nextProps.allowOverlap);\n      return {\n        layout: newLayout,\n        // We need to save these props to state for using\n        // getDerivedStateFromProps instead of componentDidMount (in which we would get extra rerender)\n        compactType: nextProps.compactType,\n        children: nextProps.children,\n        propsLayout: nextProps.layout\n      };\n    }\n    return null;\n  }\n  shouldComponentUpdate(nextProps /*: Props*/, nextState /*: State*/) /*: boolean*/{\n    return (\n      // NOTE: this is almost always unequal. Therefore the only way to get better performance\n      // from SCU is if the user intentionally memoizes children. If they do, and they can\n      // handle changes properly, performance will increase.\n      this.props.children !== nextProps.children || !(0, _utils.fastRGLPropsEqual)(this.props, nextProps, _fastEquals.deepEqual) || this.state.activeDrag !== nextState.activeDrag || this.state.mounted !== nextState.mounted || this.state.droppingPosition !== nextState.droppingPosition\n    );\n  }\n  componentDidUpdate(prevProps /*: Props*/, prevState /*: State*/) {\n    if (!this.state.activeDrag) {\n      const newLayout = this.state.layout;\n      const oldLayout = prevState.layout;\n      this.onLayoutMaybeChanged(newLayout, oldLayout);\n    }\n  }\n\n  /**\n   * Calculates a pixel value for the container.\n   * @return {String} Container height in pixels.\n   */\n  containerHeight() /*: ?string*/{\n    if (!this.props.autoSize) return;\n    const nbRow = (0, _utils.bottom)(this.state.layout);\n    const containerPaddingY = this.props.containerPadding ? this.props.containerPadding[1] : this.props.margin[1];\n    return nbRow * this.props.rowHeight + (nbRow - 1) * this.props.margin[1] + containerPaddingY * 2 + \"px\";\n  }\n  onLayoutMaybeChanged(newLayout /*: Layout*/, oldLayout /*: ?Layout*/) {\n    if (!oldLayout) oldLayout = this.state.layout;\n    if (!(0, _fastEquals.deepEqual)(oldLayout, newLayout)) {\n      this.props.onLayoutChange(newLayout);\n    }\n  }\n  /**\n   * Create a placeholder object.\n   * @return {Element} Placeholder div.\n   */\n  placeholder() /*: ?ReactElement<any>*/{\n    const {\n      activeDrag\n    } = this.state;\n    if (!activeDrag) return null;\n    const {\n      width,\n      cols,\n      margin,\n      containerPadding,\n      rowHeight,\n      maxRows,\n      useCSSTransforms,\n      transformScale\n    } = this.props;\n\n    // {...this.state.activeDrag} is pretty slow, actually\n    return /*#__PURE__*/React.createElement(_GridItem.default, {\n      w: activeDrag.w,\n      h: activeDrag.h,\n      x: activeDrag.x,\n      y: activeDrag.y,\n      i: activeDrag.i,\n      className: \"react-grid-placeholder \".concat(this.state.resizing ? \"placeholder-resizing\" : \"\"),\n      containerWidth: width,\n      cols: cols,\n      margin: margin,\n      containerPadding: containerPadding || margin,\n      maxRows: maxRows,\n      rowHeight: rowHeight,\n      isDraggable: false,\n      isResizable: false,\n      isBounded: false,\n      useCSSTransforms: useCSSTransforms,\n      transformScale: transformScale\n    }, /*#__PURE__*/React.createElement(\"div\", null));\n  }\n\n  /**\n   * Given a grid item, set its style attributes & surround in a <Draggable>.\n   * @param  {Element} child React element.\n   * @return {Element}       Element wrapped in draggable and properly placed.\n   */\n  processGridItem(child /*: ReactElement<any>*/, isDroppingItem /*: boolean*/) /*: ?ReactElement<any>*/{\n    if (!child || !child.key) return;\n    const l = (0, _utils.getLayoutItem)(this.state.layout, String(child.key));\n    if (!l) return null;\n    const {\n      width,\n      cols,\n      margin,\n      containerPadding,\n      rowHeight,\n      maxRows,\n      isDraggable,\n      isResizable,\n      isBounded,\n      useCSSTransforms,\n      transformScale,\n      draggableCancel,\n      draggableHandle,\n      resizeHandles,\n      resizeHandle\n    } = this.props;\n    const {\n      mounted,\n      droppingPosition\n    } = this.state;\n\n    // Determine user manipulations possible.\n    // If an item is static, it can't be manipulated by default.\n    // Any properties defined directly on the grid item will take precedence.\n    const draggable = typeof l.isDraggable === \"boolean\" ? l.isDraggable : !l.static && isDraggable;\n    const resizable = typeof l.isResizable === \"boolean\" ? l.isResizable : !l.static && isResizable;\n    const resizeHandlesOptions = l.resizeHandles || resizeHandles;\n\n    // isBounded set on child if set on parent, and child is not explicitly false\n    const bounded = draggable && isBounded && l.isBounded !== false;\n    return /*#__PURE__*/React.createElement(_GridItem.default, {\n      containerWidth: width,\n      cols: cols,\n      margin: margin,\n      containerPadding: containerPadding || margin,\n      maxRows: maxRows,\n      rowHeight: rowHeight,\n      cancel: draggableCancel,\n      handle: draggableHandle,\n      onDragStop: this.onDragStop,\n      onDragStart: this.onDragStart,\n      onDrag: this.onDrag,\n      onResizeStart: this.onResizeStart,\n      onResize: this.onResize,\n      onResizeStop: this.onResizeStop,\n      isDraggable: draggable,\n      isResizable: resizable,\n      isBounded: bounded,\n      useCSSTransforms: useCSSTransforms && mounted,\n      usePercentages: !mounted,\n      transformScale: transformScale,\n      w: l.w,\n      h: l.h,\n      x: l.x,\n      y: l.y,\n      i: l.i,\n      minH: l.minH,\n      minW: l.minW,\n      maxH: l.maxH,\n      maxW: l.maxW,\n      static: l.static,\n      droppingPosition: isDroppingItem ? droppingPosition : undefined,\n      resizeHandles: resizeHandlesOptions,\n      resizeHandle: resizeHandle\n    }, child);\n  }\n  render() /*: React.Element<\"div\">*/{\n    const {\n      className,\n      style,\n      isDroppable,\n      innerRef\n    } = this.props;\n    const mergedClassName = (0, _clsx.default)(layoutClassName, className);\n    const mergedStyle = {\n      height: this.containerHeight(),\n      ...style\n    };\n    return /*#__PURE__*/React.createElement(\"div\", {\n      ref: innerRef,\n      className: mergedClassName,\n      style: mergedStyle,\n      onDrop: isDroppable ? this.onDrop : _utils.noop,\n      onDragLeave: isDroppable ? this.onDragLeave : _utils.noop,\n      onDragEnter: isDroppable ? this.onDragEnter : _utils.noop,\n      onDragOver: isDroppable ? this.onDragOver : _utils.noop\n    }, React.Children.map(this.props.children, child => this.processGridItem(child)), isDroppable && this.state.droppingDOMNode && this.processGridItem(this.state.droppingDOMNode, true), this.placeholder());\n  }\n}\nexports.default = ReactGridLayout;\n// TODO publish internal ReactClass displayName transform\n_defineProperty(ReactGridLayout, \"displayName\", \"ReactGridLayout\");\n// Refactored to another module to make way for preval\n_defineProperty(ReactGridLayout, \"propTypes\", _ReactGridLayoutPropTypes.default);\n_defineProperty(ReactGridLayout, \"defaultProps\", {\n  autoSize: true,\n  cols: 12,\n  className: \"\",\n  style: {},\n  draggableHandle: \"\",\n  draggableCancel: \"\",\n  containerPadding: null,\n  rowHeight: 150,\n  maxRows: Infinity,\n  // infinite vertical growth\n  layout: [],\n  margin: [10, 10],\n  isBounded: false,\n  isDraggable: true,\n  isResizable: true,\n  allowOverlap: false,\n  isDroppable: false,\n  useCSSTransforms: true,\n  transformScale: 1,\n  verticalCompact: true,\n  compactType: \"vertical\",\n  preventCollision: false,\n  droppingItem: {\n    i: \"__dropping-elem__\",\n    h: 1,\n    w: 1\n  },\n  resizeHandles: [\"se\"],\n  onLayoutChange: _utils.noop,\n  onDragStart: _utils.noop,\n  onDrag: _utils.noop,\n  onDragStop: _utils.noop,\n  onResizeStart: _utils.noop,\n  onResize: _utils.noop,\n  onResizeStop: _utils.noop,\n  onDrop: _utils.noop,\n  onDropDragOver: _utils.noop\n});"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}